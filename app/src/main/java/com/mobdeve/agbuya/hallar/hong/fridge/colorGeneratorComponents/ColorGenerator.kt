package com.mobdeve.agbuya.hallar.hong.fridge.colorGeneratorComponents
import android.graphics.Color
import kotlin.random.Random

data class RgbColorRange(
    val red: ComponentColorRange = ComponentColorRange(0, 255),
    val green: ComponentColorRange = ComponentColorRange(0, 255),
    val blue: ComponentColorRange = ComponentColorRange(0, 255)
)


class ColorGenerator(private val initialExcludedColorsHex: List<String>) {

    private val fixedExcludedColorsInt: Set<Int>

    private val generatedColorsHistory: MutableSet<Int> = mutableSetOf()

    init {
        fixedExcludedColorsInt = initialExcludedColorsHex.map { Color.parseColor(it) }.toSet()
    }

    /** NULLABLE
     * Generates a random color within the specified RGB ranges,
     * ensuring it's not one of the initially defined excluded colors
     * OR any color previously generated by this instance (until history is cleared).
     *
     * @param range The RgbColorRange to generate colors from. Defaults to the full RGB spectrum.
     * @param maxAttempts Maximum number of attempts to generate a non-excluded color.

     * @return A random color as an [Int] (ARGB format, typically opaque `0xFFRRGGBB`),
     * or `null` if a non-excluded color could not be generated within `maxAttempts`.
     */
    fun getRandomColor(range: RgbColorRange = FULL_RGB_RANGE, maxAttempts: Int = 100): Int? {
        var attempts = 0
        // Combine fixed exclusions and historical generated colors for the current check
        // This creates a new set for each call to getRandomColor for safety,
        // but it's generally efficient enough.
        val currentExclusions = fixedExcludedColorsInt + generatedColorsHistory

        while (attempts < maxAttempts) {
            val r = Random.nextInt(range.red.min, range.red.max + 1)
            val g = Random.nextInt(range.green.min, range.green.max + 1)
            val b = Random.nextInt(range.blue.min, range.blue.max + 1)

            // Color.rgb creates an opaque color (alpha FF)
            val generatedColor = Color.rgb(r, g, b)

            // Check if the newly generated color is in the combined excluded set
            if (generatedColor !in currentExclusions) {
                // If it's a valid, non-excluded color, add it to history before returning
                generatedColorsHistory.add(generatedColor)
                return generatedColor
            }
            attempts++
        }
        // Log a warning if a suitable color couldn't be found after many attempts
        println(
            "ColorGenerator Warning: Could not generate a non-excluded color " +
                    "within $maxAttempts attempts for range: $range. " +
                    "Consider adjusting range or the excluded color lists (fixed/history)."
        )
        return null // Failed to find a non-excluded color
    }

    /**
     * Clears the history of previously generated colors. After this,
     * those colors can potentially be generated again.
     */
    fun clearGeneratedHistory() {
        generatedColorsHistory.clear()
        println("ColorGenerator: Generated colors history cleared.")
    }



    /**
     * Companion object to hold common predefined color ranges.
     */
    companion object {
        // A default RgbColorRange representing the full spectrum (0-255 for all components)
        val FULL_RGB_RANGE = RgbColorRange(
            red = ComponentColorRange(0, 255),
            green = ComponentColorRange(0, 255),
            blue = ComponentColorRange(0, 255)
        )
    }
}